<div class="row d-flex justify-content-center">
    <h2 class="m-5">Architecture</h2><br>
</div>
<div class="row d-flex justify-content-center mb-5">
    <div class="col"><p> 
        Goblint is implemented in OCaml and uses an updated fork of CIL as its parser frontend for the C language.
        The architecture of Goblint is designed to be modular. 
        Analyses, which are defined by their abstract domains and transfer functions, can be activated via runtime configuration options. 
        A flexible query system allows for communication between analyses. 
        Together, the combined analyses and the control-flow graphs of the functions in the program provide the side-effecting constraint system, 
        which is solved by some local generic solver. 
        Post-processing the solution yields results for the analysis.
    </p></div>
</div>
<div class="row d-flex justify-content-center">
    <h2 class="m-5">Overview of Goblint Features</h2><br>
</div>
<div class="row d-flex justify-content-center mb-5">
    <div class="col"><h4>Race detection</h4></div>
    <div class="col"><h4>Path-sensitivity</h4></div>
    <div class="col"><h4>Thread-modularity</h4></div>
    <div class="col"><h4>Starvation analysis</h4></div>
    <div class="w-100"></div>
    <div class="col"><p class="flex-grow-1"> The main application of this framework is for race detection. 
        Goblint checks  that all accesses to shared memory are protected by a common mutex.</p></div>
    <div class="col"><p class="flex-grow-1"> Goblint is path-sensitive, so it deals with conditional locking schemes as well as possibly failing, 
        interruptible and probing locking primitives. Mutexes may be handled both pathsensitively and symbolically.</p></div>
    <div class="col"><p class="flex-grow-1"> Goblint performs thread-modular analysis of C programs. 
        It computes a sound upper approximation of all possible thread interleavings using global invariants for shared data.</p>
    </div>
    <div class="col"><p class="flex-grow-1"> ...</p>
    </div>
</div>
<div class="row d-flex justify-content-center mb-5">
    <div class="col"><h4>Incremental analysis of Git repositories</h4></div>
    <div class="col"><h4>Fixpoint algorithms</h4></div>
    <div class="col"><h4>Global invariant</h4></div>
    <div class="col"><h4>HTML front-end</h4></div>
    <div class="w-100"></div>
    <div class="col"><p class="flex-grow-1">Incremental analysis of Git repositories</p>
    </div>
    <div class="col"><p class="flex-grow-1"> Generic fixpoint algorithms with widening and narrowing.</p></div>
    <div class="col"><p class="flex-grow-1"> Global invariant approach and side-effecting.</p></div>
    <div class="col"><p class="flex-grow-1"> Visualisation of results.</p></div>
</div>

<div class="row d-flex justify-content-center">
    <h2 class="m-5">Example</h2>
</div>
<div class="row d-flex justify-content-center">
    <p class="text-justify">The following screenshot illustrates the result of running the analyzer on a simple program with a static array of mutexes. </p>
    <a href="images/screen.png" target="_self"><img src="assets/images/screen.png" alt="Screenshot" width="720" height="522" class="m-5"/></a>
    <p class="text-justify">The safe incrementation function increases an element in the data array while acquiring the corresponding mutex; however, 
        the main thread erroneously increments the third element while having locked the fourth lock.</p>
        
    <p class="text-justify">As the example shows, Goblint not only tracks the flow of locks in and out of functions, 
        but carefully considers the values and equalities between indexing variables to infer correlations. 
    </p> 
</div>

<app-authors></app-authors>