<div class="row d-flex justify-content-center">
    <h2 class="m-5">Architecture</h2><br>
</div>
<div class="row d-flex justify-content-center mb-5">
    <div class="col"><p> 
        Goblint is implemented in OCaml and uses an updated fork of CIL as its parser frontend for the C language.
        The architecture of Goblint is designed to be modular. 
        Analyses, which are defined by their abstract domains and transfer functions, can be activated via runtime configuration options. 
        A flexible query system allows for communication between analyses. 
        Together, the combined analyses and the control-flow graphs of the functions in the program provide the side-effecting constraint system, 
        which is solved by some local generic solver. 
        Post-processing the solution yields results for the analysis.
    </p></div>
</div>
<div class="row d-flex justify-content-center">
    <h2 class="m-5">Overview of Goblint Features</h2><br>
</div>
<div class="row d-flex justify-content-center mb-5">
    <div class="col"><h4>Race detection</h4></div>
    <div class="col"><h4>Path-sensitivity</h4></div>
    <div class="col"><h4>Multi-threaded C programs</h4></div>
    <div class="col"><h4>Reader/writer locks</h4></div>
    <div class="w-100"></div>
    <div class="col"><p class="flex-grow-1"> The main application of this framework is for race detection. 
        Goblint checks  that all accesses to shared memory are protected by a common mutex.</p></div>
    <div class="col"><p class="flex-grow-1"> Goblint is path-sensitive, so it deals with conditional locking schemes as well as possibly failing, 
        interruptible and probing locking primitives. Mutexes may be handled both pathsensitively and symbolically.</p></div>
    <div class="col"><p class="flex-grow-1"> Goblint is an analyzer of multi-threaded C programs. 
        It computes a sound upper approximation of all possible thread interleavings using global invariants for shared data.</p>
    </div>
    <div class="col"><p class="flex-grow-1"> Goblint also supports reader/writer locks.</p></div>
</div>
<div class="row d-flex justify-content-center">
    <div class="col"><h4>Reachability safety</h4></div>
    <div class="col"><h4>Handling pointers</h4></div>
    <div class="col"><h4>Partitioning</h4></div>
    <div class="col"><h4>No overflows</h4></div>
    <div class="w-100"></div>
    <div class="col"><p class="flex-grow-1"> Reachability is mainly determined using value analysis, which, for integers, employs abstract domains based on intervals and exclusion sets.</p>
    </div>
    <div class="col"><p class="flex-grow-1"> The value analysis also handles pointers (computing points-to information), heap memory (using allocation-site abstraction), structs, unions and arrays.</p></div>
    <div class="col"><p class="flex-grow-1">  The abstraction of arrays employs partitioning by the symbolic expression that is used to index into the array. On top of that, both global variables and heap-allocated memory are partitioned into disjoint regions</p>
    </div>
    <div class="col"><p class="flex-grow-1"> The sound interval analysis is implemented using arbitrary precision integers. If the interval for an expression lies completely in the value range
        of its signed integer type, no overflow can occur at this location.</p></div>
</div>

<div class="row d-flex justify-content-center">
    <h2 class="m-5">Example</h2>
</div>
<div class="row d-flex justify-content-center">
    <p class="text-justify">The following screenshot illustrates the result of running the analyzer on a simple program with a static array of mutexes. </p>
    <a href="images/screen.png" target="_self"><img src="assets/images/screen.png" alt="Screenshot" width="720" height="522" class="m-5"/></a>
    <p class="text-justify">The safe incrementation function increases an element in the data array while acquiring the corresponding mutex; however, 
        the main thread erroneously increments the third element while having locked the fourth lock.</p>
        
    <p class="text-justify">As the example shows, Goblint not only tracks the flow of locks in and out of functions, 
        but carefully considers the values and equalities between indexing variables to infer correlations. 
    </p> 
</div>

<app-authors></app-authors>